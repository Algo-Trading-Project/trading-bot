from vectorbtpro.portfolio.base import Portfolio
from backtest.strategies.single_asset.base_strategy import BaseStrategy
from backtest.strategies.portfolio.base_strategy import BasePortfolioStrategy

import pandas as pd
import numpy as np

class WalkForwardOptimization:
 
    def __init__(
        self, 
        strategy: BaseStrategy,
        backtest_data: pd.DataFrame,
        is_start_i: int,
        is_end_i: int,
        oos_start_i: int,
        oos_end_i: int,
        resample_period: str
    ):
                
        """
        Performs a walk-forward optimization on an arbitrary strategy over an arbitrary token.  
        Logs the backtest_resultulting trades and equity curve to Redshift for further dashboarding/analysis.

        Parameters
        ----------
        strategy : BaseStrategy
            Strategy class in backtest/strategies to backtest.

        backtest_data : pd.DataFrame
            Dataframe of OHLCV data indexed by timestamp.

        is_start_i : int
            Starting index of in-sample optimization period.

        is_end_i : int
            End index of in-sample optimization period.

        oos_start_i : int
            Starting index of out-of-sample period.

        oos_end_i : int
            End index of out-of-sample period.
        """
        
        self.strategy = strategy
        self.backtest_data = backtest_data
        self.is_start_i = is_start_i
        self.is_end_i = is_end_i
        self.oos_start_i = oos_start_i
        self.oos_end_i = oos_end_i
        self.resample_period = resample_period
        
    def __generate_signals(
        self, 
        params: dict, 
        optimize: bool
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """
        Generates and returns entry/exit signals by applying the strategy to the provided OHLCV data
        with a specific combination of parameters.

        Parameters
        ----------
        params : (dict)
            Dictionary containing the specific parameter combination to use to generate entry/exit signals.
            If params contains lists for values instead of ints/floats, then apply the strategy on every
            combination of parameters and return them all

        optimize : (bool)
            Indicates whether or not we are in an in-sample optimization period or an out-of-sample period

        Returns
        -------
        np.ndarray
            Array of entry signals generated by the strategy

        np.ndarray
            Array of exit signals generated by the strategy

        np.ndarray
            Array of take-profit percentages generated by the strategy

        np.ndarray
            Array of stop-loss percentages generated by the strategy

        np.ndarray
            Array of position size percentages generated by the strategy
        """

        # If we are in an in-sample optimization period, we only apply the strategy to the in-sample data
        if optimize:
            backtest_window = self.backtest_data.iloc[self.is_start_i:self.is_end_i]

            if issubclass(type(self.strategy), BasePortfolioStrategy):
                perf = self.strategy.indicator_func(
                    backtest_window,
                    **params
                )
                # Get the maximizing index of the performance metric DataFrame/Series
                best_param_comb = perf.idxmax()
                print(best_param_comb)
                best_param_comb = dict(zip(self.strategy.optimize_dict.keys(), best_param_comb))
                print(best_param_comb)

                # Backtest the strategy on the out-of-sample period with the optimal 
                # parameters for the in-sample period
                print()
                print('best_param_comb', best_param_comb)
                print()
                best_is_port = self.strategy.run_strategy_with_parameter_combination(
                    backtest_window, 
                    **best_param_comb
                )

                # Return the optimal in-sample parameter combination and the 
                # portfolio generated by the optimal parameter combination
                return best_param_comb, best_is_port

            elif issubclass(type(self.strategy), BaseStrategy):
                perf = self.strategy.indicator_func(
                    open = backtest_window.open,
                    high = backtest_window.high,
                    low = backtest_window.low,
                    close = backtest_window.close,
                    volume = backtest_window.volume,
                    trades_count = backtest_window.trades,
                    symbol_id = self.strategy.symbol_id,
                    **params
                )
                # Get the maximizing index of the performance metric DataFrame/Series
                best_param_comb = list(perf.idxmax())

                # perf is a Series, so there is only one parameter for the strategy
                if type(best_param_comb) == float or type(best_param_comb) == int:
                    best_param_comb = {perf.index.name: best_param_comb}

                # perf is a DataFrame, so there are multiple parameters for the strategy
                else:
                    best_param_comb = dict(zip(perf.index.names, best_param_comb))

                # Backtest the strategy on the out-of-sample period with the optimal
                # parameters for the in-sample period
                best_is_port = self.strategy.run_strategy_with_parameter_combination(
                    open = backtest_window.open,
                    high = backtest_window.high,
                    low = backtest_window.low,
                    close = backtest_window.close,
                    volume = backtest_window.volume,
                    trades_count = backtest_window.trades,
                    symbol_id = self.strategy.symbol_id,
                    **best_param_comb
                )

                # Return the optimal in-sample parameter combination and the
                # portfolio generated by the optimal parameter combination
                return best_param_comb, best_is_port

            else:
                raise ValueError('Invalid strategy type')

        # If we are in an out-of-sample period, we apply the strategy to the in-sample and out-of-sample data
        # This allows us to access historical data in the in-sample period to help generate signals for the out-of-sample period
        else:
            backtest_window = self.backtest_data.iloc[self.is_start_i:self.oos_end_i]

            if issubclass(type(self.strategy), BasePortfolioStrategy):
                oos_port = self.strategy.run_strategy_with_parameter_combination(
                    backtest_window, 
                    **params
                )
                
                # Return out-of-sample portfolio backtested on 
                # the optimal in-sample parameters
                return oos_port

            elif issubclass(type(self.strategy), BaseStrategy):
                oos_port = self.strategy.run_strategy_with_parameter_combination(
                    open = backtest_window.open,
                    high = backtest_window.high,
                    low = backtest_window.low,
                    close = backtest_window.close,
                    volume = backtest_window.volume,
                    trades_count = backtest_window.trades,
                    **params
                )
                
                # Return out-of-sample portfolio backtested on 
                # the optimal in-sample parameters
                return oos_port

            else:
                raise ValueError('Invalid strategy type')
    
    def walk_forward(self, params: dict) -> tuple[pd.DataFrame, pd.Series]:
        """
        Performs an out-of-sample backtest w/ the given strategy.  Returns the trades and equity curve of
        the backtest.

        Parameters
        ----------
        params : dict
            Dictionary of optimal strategy parameters to use in the out-of-sample backtest.

        Returns
        -------
        pd.DataFrame
            DataFrame of trades made during the out-of-sample backtest.

        pd.DataFrame
            DataFrame of the equity curve of the out-of-sample backtest.

        """

        # Generate signals for the out-of-sample period to backtest on
        oos_port = self.__generate_signals(
            params = params, 
            optimize = False
        )

        # Get the out-of-sample data to backtest on
        oos_data = self.backtest_data.iloc[self.oos_start_i:self.oos_end_i]
        
        # Get the equity curve of the backtest
        equity_curve = oos_port.value.to_frame()
        equity_curve = equity_curve.rename({equity_curve.columns[0]:'equity'}, axis = 1)
        
        # TODO: Check what values 'Column' column take when backtesting a single-token strategy
        # Get trades made during the backtest
        rename_dict = {
            'Entry Index':'entry_date', 'Exit Index':'exit_date', 
            'Column':'symbol_id', 'Size':'size', 'Entry Fees':'entry_fees',
            'Exit Fees':'exit_fees', 'PnL':'pnl', 'Return':'pnl_pct', 'Direction':'is_long',
            'Status':'status'
        }
        cols = ['Entry Index', 'Exit Index', 'Column', 'Size', 'Entry Fees', 'Exit Fees', 'PnL', 'Return', 'Direction', 'Status']

        positions = oos_port.positions.records_readable
        positions = positions[cols]
        positions = positions.rename(rename_dict, axis = 1)
        positions['entry_date'] = pd.to_datetime(positions['entry_date'])
        positions['exit_date'] = pd.to_datetime(positions['exit_date'])
        positions['is_long'] = positions['is_long'] == 'Long'
        positions = positions[positions['status'] == 'Closed']
        positions = positions.reset_index(drop = True)

        # Return the trades and equity curve of the backtest
        return positions, equity_curve, oos_port

    def optimize(self) -> tuple[dict, Portfolio]:
        """
        Optimizes strategy performance on the in-sample data over all parameter combinations.

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Strategy parameter combination which optimizes the selected performance metric over
            the in-sample data.

        vbt.b
            The portfolio of the backtest that optimizes the selected performance metric over the
            in-sample data.
            
        """
        return self.__generate_signals(
            params = self.strategy.optimize_dict,
            optimize = True
        )