import vectorbtpro as vbt

from vectorbtpro.portfolio.base import Portfolio
from backtest.strategies.single_asset.base_strategy import BaseStrategy
from backtest.strategies.portfolio.base_strategy import BasePortfolioStrategy

import pandas as pd
import numpy as np
import itertools

class WalkForwardOptimization:
 
    def __init__(
        self, 
        strategy,
        backtest_data: pd.DataFrame,
        is_start_i: int,
        is_end_i: int,
        oos_start_i: int,
        oos_end_i: int,
        optimization_metric: str,
        resample_period: str
    ):
                
        """
        Performs a walk-forward optimization on an arbitrary strategy over an arbitrary token.  
        Logs the backtest_resultulting trades and equity curve to Redshift for further dashboarding/analysis.

        Parameters
        ----------
        strategy : Strategy
            Strategy class in backtest/strategies to backtest.

        backtest_data : pd.DataFrame
            Dataframe of OHLCV data indexed by timestamp.

        is_start_i : int
            Starting index of in-sample optimization period.

        is_end_i : int
            End index of in-sample optimization period.

        oos_start_i : int
            Starting index of out-of-sample period.

        oos_end_i : int
            End index of out-of-sample period.

        optimization_metric : str
            Performance metric to optimize backtests on.
        """
        
        self.strategy = strategy
        self.backtest_data = backtest_data
        self.is_start_i = is_start_i
        self.is_end_i = is_end_i
        self.oos_start_i = oos_start_i
        self.oos_end_i = oos_end_i
        self.optimization_metric = optimization_metric

        self.metric_map = {
            'Total Return':'total_return',
            'Max Drawdown':'drawdowns.max_drawdown',
            'Max Drawdown Duration':'drawdowns.max_duration',
            'Win Rate':'trades.win_rate',
            'Profit Factor':'trades.profit_factor',
            'Expectancy':'trades.expectancy',
            'Sharpe Ratio':'returns_acc.sharpe_ratio',
            'Calmar Ratio':'returns_acc.calmar_ratio',
            'Omega Ratio':'returns_acc.omega_ratio',
            'Sortino Ratio':'returns_acc.sortino_ratio'
        }

        self.metric_min_max_map = {
            'Total Return':'Max',
            'Max Drawdown':'Min',
            'Max Drawdown Duration':'Min',
            'Win Rate':'Max',
            'Profit Factor':'Max',
            'Expectancy':'Max',
            'Sharpe Ratio':'Max',
            'Calmar Ratio':'Max',
            'Omega Ratio':'Max',
            'Sortino Ratio':'Max'
        }

        self.resample_period = resample_period
        
    def __generate_signals(
        self, 
        params: dict, 
        optimize: bool
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """
        Generates and returns entry/exit signals by applying the strategy to the provided OHLCV data
        with a specific combination of parameters.

        Parameters
        ----------
        params : (dict)
            Dictionary containing the specific parameter combination to use to generate entry/exit signals.
            If params contains lists for values instead of ints/floats, then apply the strategy on every
            combination of parameters and return them all

        optimize : (bool)
            Indicates whether or not we are in an in-sample optimization period or an out-of-sample period

        Returns
        -------
        np.ndarray
            Array of entry signals generated by the strategy

        np.ndarray
            Array of exit signals generated by the strategy

        np.ndarray
            Array of take-profit percentages generated by the strategy

        np.ndarray
            Array of stop-loss percentages generated by the strategy

        np.ndarray
            Array of position size percentages generated by the strategy
        """

        # If we are in an in-sample optimization period, we only apply the strategy to the in-sample data
        if optimize:
            backtest_window = self.backtest_data.iloc[self.is_start_i:self.is_end_i]

            if issubclass(type(self.strategy), BasePortfolioStrategy):
                perf = self.strategy.indicator_func(
                    backtest_window,
                    **params
                )
                # Get the maximizing index of the performance metric DataFrame/Series
                best_param_comb = list(perf.idxmax())
                
                # perf is a Series, so there is only one parameter for the strategy
                if type(best_param_comb) == float or type(best_param_comb) == int:
                    best_param_comb = {perf.index.name: best_param_comb}

                # perf is a DataFrame, so there are multiple parameters for the strategy
                else:
                    best_param_comb = dict(zip(perf.index.names, best_param_comb))

                # Backtest the strategy on the out-of-sample period with the optimal 
                # parameters for the in-sample period
                best_is_port = self.strategy.run_strategy_with_parameter_combination(
                    backtest_window, 
                    **best_param_comb
                )

                # Return the optimal in-sample parameter combination and the 
                # portfolio generated by the optimal parameter combination
                return best_param_comb, best_is_port

            elif issubclass(type(self.strategy), BaseStrategy):
                # TODO: Implement for single token strategies
                perf = self.strategy.indicator_func(
                    open = backtest_window.open,
                    high = backtest_window.high,
                    low = backtest_window.low,
                    close = backtest_window.close,
                    volume = backtest_window.volume,
                    trades_count = backtest_window.trades,
                    symbol_id = self.strategy.symbol_id,
                    **params
                )
                best_param_comb = perf.idxmax()
                print(best_param_comb)
            else:
                raise ValueError('Invalid strategy type')

        # If we are in an out-of-sample period, we apply the strategy to the in-sample and out-of-sample data
        # This allows us to access historical data in the in-sample period to help generate signals for the out-of-sample period
        else:
            backtest_window = self.backtest_data.iloc[self.is_start_i:self.oos_end_i]

            if issubclass(type(self.strategy), BasePortfolioStrategy):
                oos_port = self.strategy.run_strategy_with_parameter_combination(
                    backtest_window, 
                    **params
                )
                
                # Return out-of-sample portfolio backtested on 
                # the optimal in-sample parameters
                return oos_port

            # TODO: Implement for single token strategies
            elif issubclass(type(self.strategy), BaseStrategy):
                pass

            else:
                raise ValueError('Invalid strategy type')
    
    def walk_forward(self, params: dict) -> tuple[pd.DataFrame, pd.Series]:
        """
        Performs an out-of-sample backtest w/ the given strategy.  Returns the trades and equity curve of
        the backtest.

        Parameters
        ----------
        params : dict
            Dictionary of optimal strategy parameters to use in the out-of-sample backtest.

        Returns
        -------
        pd.DataFrame
            DataFrame of trades made during the out-of-sample backtest.

        pd.DataFrame
            DataFrame of the equity curve of the out-of-sample backtest.

        """

        # Generate signals for the out-of-sample period to backtest on
        oos_port = self.__generate_signals(
            params = params, 
            optimize = False
        )

        # Get the out-of-sample data to backtest on
        oos_data = self.backtest_data.iloc[self.oos_start_i:self.oos_end_i]
        
        # Get equity curve of the backtest
        equity_curve = oos_port.value.to_frame()
        equity_curve = equity_curve.rename({equity_curve.columns[0]:'equity'}, axis = 1)
        
        # Get trades made during the backtest
        rename_dict = {
            'Entry Index':'entry_date', 'Exit Index':'exit_date', 
            'PnL':'pnl', 'Return':'pnl_pct', 'Direction':'is_long'
        }
        trades = oos_port.trades.records_readable
        trades = trades[['Entry Index', 'Exit Index', 'PnL', 'Return', 'Direction']]
        trades = trades.rename(rename_dict, axis = 1)
        trades['entry_date'] = pd.to_datetime(trades['entry_date'])
        trades['exit_date'] = pd.to_datetime(trades['exit_date'])
        trades['is_long'] = trades['is_long'] == 'Long'

        # Return the trades and equity curve of the backtest
        return trades, equity_curve

    def optimize(self) -> tuple[dict, Portfolio]:
        """
        Optimizes strategy performance on the in-sample data over all parameter combinations.

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Strategy parameter combination which optimizes the selected performance metric over
            the in-sample data.

        vbt.b
            The portfolio of the backtest that optimizes the selected performance metric over the
            in-sample data.
            
        """
        return self.__generate_signals(
            params = self.strategy.optimize_dict,
            optimize = True
        )